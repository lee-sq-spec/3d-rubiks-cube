<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rubik's Master Final</title>
    <style>
        :root { --bg: #050505; --cyan: #00f2ff; --gold: #f1c40f; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: sans-serif; color: white; touch-action: none; }
        
        /* 关键：UI 层级既要浮动，又要让点击穿透到 3D 场景 */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 100; display: flex; flex-direction: column; justify-content: space-between; padding: 15px; }
        .pointer { pointer-events: auto; }
        
        .card { background: rgba(30,30,30,0.9); padding: 12px; border-radius: 12px; border: 1px solid #444; width: 220px; }
        .timer { font-family: monospace; font-size: 30px; color: var(--gold); }

        #palette { display: none; position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: rgba(30,30,30,0.9); padding: 10px; border-radius: 20px; flex-direction: column; gap: 12px; border: 1px solid #555; }
        .ink { width: 35px; height: 35px; border-radius: 50%; cursor: pointer; border: 3px solid transparent; }
        .ink.active { border-color: white; box-shadow: 0 0 10px white; }

        .controls { display: flex; flex-direction: column; align-items: center; gap: 10px; padding-bottom: 25px; }
        .move-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; background: rgba(30,30,30,0.9); padding: 10px; border-radius: 12px; }
        .move-btn { width: 55px; height: 45px; background: #444; color: white; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; }
        .move-btn:active { background: var(--cyan); color: #000; }

        .btn-m { background: #222; color: white; border: none; padding: 10px 14px; border-radius: 6px; font-size: 12px; cursor: pointer; }
        .btn-m.active { background: var(--cyan); color: #000; font-weight: bold; }
        .scramble { background: #e67e22; font-weight: bold; padding: 12px 30px; border-radius: 8px; border: none; color: white; cursor: pointer; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="top pointer">
        <div class="card">
            <div id="m-title" style="color:var(--cyan); font-weight:bold; font-size: 14px;">CLASSIC / 经典模式</div>
            <div id="timer" class="timer">00:00.0</div>
            <div id="assist-box" style="display:none; margin-top:8px;">
                <button onclick="calcSolve()" style="background:#2ecc71; color:white; border:none; padding:8px; border-radius:4px; width:100%;">计算复原 / Solve</button>
                <button id="step-btn" onclick="execStep()" style="display:none; background:#9b59b6; color:white; border:none; padding:8px; border-radius:4px; width:100%; margin-top:5px;">下一步 / Next Step</button>
            </div>
        </div>
    </div>

    <div id="palette" class="pointer">
        <div class="ink active" style="background:#fff" onclick="pick(0,this)"></div>
        <div class="ink" style="background:#ff0" onclick="pick(1,this)"></div>
        <div class="ink" style="background:#f90" onclick="pick(2,this)"></div>
        <div class="ink" style="background:#f00" onclick="pick(3,this)"></div>
        <div class="ink" style="background:#0f0" onclick="pick(4,this)"></div>
        <div class="ink" style="background:#00f" onclick="pick(5,this)"></div>
    </div>

    <div class="controls pointer">
        <div class="move-grid" id="move-btns">
            <button class="move-btn" onclick="move('y', 2, 1)">U</button>
            <button class="move-btn" onclick="move('y', 0, -1)">D</button>
            <button class="move-btn" onclick="move('x', 0, -1)">L</button>
            <button class="move-btn" onclick="move('x', 2, 1)">R</button>
            <button class="move-btn" onclick="move('z', 2, 1)">F</button>
            <button class="move-btn" onclick="move('z', 0, -1)">B</button>
        </div>
        <div style="display:flex; gap:8px;">
            <button onclick="setM('Classic')" id="m-c" class="btn-m active">经典/Classic</button>
            <button onclick="setM('Time')" id="m-t" class="btn-m">计时/Time</button>
            <button onclick="setM('Assist')" id="m-a" class="btn-m">辅助/Assist</button>
        </div>
        <button class="scramble" onclick="runScramble()">打乱魔方 / SCRAMBLE</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
let scene, camera, renderer, controls, cubeGroup, cubies = [];
let isMoving = false, mode = 'Classic', inkIdx = 0;
let history = [], solution = [], startTime, timerItv, isRacing = false;
const COLORS = [0xffffff, 0xffff00, 0xffa500, 0xff0000, 0x00ff00, 0x0046ad];

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(8, 8, 12);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    createCube();
    animate();

    renderer.domElement.addEventListener('pointerdown', handleTouch);
}

function createCube() {
    if(cubeGroup) scene.remove(cubeGroup);
    cubeGroup = new THREE.Group();
    cubies = [];
    for(let x=0; x<3; x++) {
        for(let y=0; y<3; y++) {
            for(let z=0; z<3; z++) {
                if(x==1 && y==1 && z==1) continue;
                const geom = new THREE.BoxGeometry(0.97, 0.97, 0.97);
                const mats = [3, 2, 0, 1, 4, 5].map(i => new THREE.MeshLambertMaterial({ color: COLORS[i] }));
                const m = new THREE.Mesh(geom, mats);
                m.position.set(x-1, y-1, z-1);
                m.userData.home = m.position.clone();
                cubeGroup.add(m);
                cubies.push(m);
            }
        }
    }
    scene.add(cubeGroup);
}

function move(axis, layer, dir, track = true) {
    if(isMoving) return;
    isMoving = true;
    if(track) history.push({axis, layer, dir});

    const pivot = new THREE.Group();
    scene.add(pivot);
    const targets = cubies.filter(c => {
        const p = new THREE.Vector3();
        c.getWorldPosition(p);
        return Math.abs(p[axis] - (layer - 1)) < 0.1;
    });

    targets.forEach(c => pivot.attach(c));
    new TWEEN.Tween(pivot.rotation).to({ [axis]: pivot.rotation[axis] + (Math.PI/2 * dir) }, 300)
        .onComplete(() => {
            targets.forEach(c => {
                cubeGroup.attach(c);
                c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
                c.rotation.set(Math.round(c.rotation.x/(Math.PI/2))*(Math.PI/2), Math.round(c.rotation.y/(Math.PI/2))*(Math.PI/2), Math.round(c.rotation.z/(Math.PI/2))*(Math.PI/2));
            });
            scene.remove(pivot);
            isMoving = false;
            if(isRacing) checkWin();
        }).start();
}

function handleTouch(e) {
    if(mode !== 'Assist') return;
    const ray = new THREE.Raycaster();
    const m = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
    ray.setFromCamera(m, camera);
    const hits = ray.intersectObjects(cubies);
    if(hits.length > 0) {
        const f = Math.floor(hits[0].faceIndex / 2);
        hits[0].object.material[f].color.setHex(COLORS[inkIdx]);
    }
}

function setM(m) {
    mode = m; isRacing = false;
    clearInterval(timerItv);
    document.getElementById('timer').innerText = "00:00.0";
    document.querySelectorAll('.btn-m').forEach(b => b.classList.remove('active'));
    document.getElementById('palette').style.display = (m==='Assist'?'flex':'none');
    document.getElementById('assist-box').style.display = (m==='Assist'?'block':'none');
    document.getElementById('move-btns').style.display = (m==='Assist'?'none':'grid');
    document.getElementById('m-title').innerText = m.toUpperCase() + (m==='Time'?'/计时':'/经典');
    if(m==='Assist') history = [];
}

function runScramble() {
    history = [];
    let n = 0;
    const itv = setInterval(() => {
        move(['x','y','z'][Math.floor(Math.random()*3)], Math.floor(Math.random()*3), 1);
        if(++n >= 10) {
            clearInterval(itv);
            if(mode === 'Time') {
                startTime = Date.now(); isRacing = true;
                timerItv = setInterval(() => {
                    document.getElementById('timer').innerText = ((Date.now()-startTime)/1000).toFixed(1) + 's';
                }, 100);
            }
        }
    }, 350);
}

function calcSolve() {
    if(history.length === 0) return alert("已是复原状态 / Already solved");
    solution = [...history].reverse().map(i => ({...i, dir: -i.dir}));
    document.getElementById('step-btn').style.display = 'block';
}

function execStep() {
    if(solution.length > 0) {
        const s = solution.shift();
        move(s.axis, s.layer, s.dir, false);
        if(solution.length === 0) {
            document.getElementById('step-btn').style.display = 'none';
            history = []; alert("复原完成 / Solved!");
        }
    }
}

function checkWin() {
    const win = cubies.every(c => c.getWorldPosition(new THREE.Vector3()).distanceTo(c.userData.home) < 0.1);
    if(win && isRacing) {
        clearInterval(timerItv);
        alert("完成！时间: " + document.getElementById('timer').innerText);
        isRacing = false;
    }
}

function pick(i, el) {
    inkIdx = i;
    document.querySelectorAll('.ink').forEach(n => n.classList.remove('active'));
    el.classList.add('active');
}

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
