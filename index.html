<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Rubik's Cube Pro | 3D 专业魔方</title>
    <style>
        :root { --primary: #3498db; --accent: #2ecc71; --bg: #0d0d0d; --panel: rgba(25, 25, 25, 0.9); }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; color: white; }
        
        /* UI 容器 */
        #game-ui { position: absolute; inset: 0; pointer-events: none; z-index: 100; display: flex; flex-direction: column; justify-content: space-between; padding: 15px; }
        .pointer { pointer-events: auto; }

        /* 顶部面板：状态与历史 */
        .header { display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; }
        .info-panel { background: var(--panel); backdrop-filter: blur(10px); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); min-width: 140px; }
        .timer { font-family: 'Courier New', monospace; font-size: 28px; color: #f1c40f; font-weight: bold; }
        .mode-label { font-size: 13px; color: #aaa; margin-bottom: 4px; border-bottom: 1px solid #333; padding-bottom: 4px; }

        /* 历史记录：只显示最新10条 */
        .history-panel { width: 220px; background: var(--panel); border-radius: 12px; padding: 12px; font-size: 12px; border: 1px solid rgba(255,255,255,0.1); }
        .history-title { border-bottom: 1px solid #444; padding-bottom: 8px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
        .history-title b { color: var(--primary); }
        .history-list { list-style: none; padding: 0; margin: 0; max-height: 180px; overflow-y: auto; }
        .history-item { padding: 6px 0; border-bottom: 1px solid #333; display: flex; flex-direction: column; gap: 2px; }
        .history-item .meta { display: flex; justify-content: space-between; color: #888; font-size: 10px; }
        .history-item .data { display: flex; justify-content: space-between; font-weight: bold; }

        /* 底部控制栏 */
        .controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; padding-bottom: 20px; }
        .btn-group { display: flex; background: var(--panel); padding: 6px; border-radius: 10px; gap: 6px; border: 1px solid rgba(255,255,255,0.1); }
        
        button { 
            background: #3a3a3a; color: white; border: none; padding: 8px 16px; border-radius: 6px; 
            cursor: pointer; font-size: 13px; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; line-height: 1.2;
        }
        button span { font-size: 10px; opacity: 0.7; font-weight: normal; }
        button:active { transform: scale(0.92); }
        button.active { background: var(--primary); box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
        button.scramble { background: #e67e22; font-weight: bold; }
        button.solve { background: var(--accent); }

        /* 滚动条美化 */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 10px; }

        @media (max-width: 600px) {
            .header { flex-direction: column; }
            .history-panel { width: 100%; }
            button { padding: 6px 10px; font-size: 12px; }
        }
    </style>
</head>
<body>

<div id="game-ui">
    <div class="header">
        <div class="info-panel pointer">
            <div id="mode-text" class="mode-label">经典模式 Classic</div>
            <div id="timer-display" class="timer">00:00.0</div>
            <div id="size-display" style="font-size: 12px; color: #888; margin-top:5px;">尺寸 Size: 3x3</div>
        </div>

        <div class="history-panel pointer">
            <div class="history-title">
                <span>历史记录 History (Latest 10)</span>
                <b id="log-count">0/10</b>
            </div>
            <ul id="history-list" class="history-list">
                </ul>
        </div>
    </div>

    <div class="controls pointer">
        <div class="btn-group">
            <button onclick="changeMode('Classic')" id="btn-Classic" class="active">经典模式<span>Classic</span></button>
            <button onclick="changeMode('Time Trial')" id="btn-TimeTrial">计时挑战<span>Time Trial</span></button>
            <button onclick="changeMode('Solve Assist')" id="btn-SolveAssist">辅助模式<span>Assist</span></button>
        </div>
        
        <div class="btn-group">
            <button onclick="changeSize(3)">3x3</button>
            <button onclick="changeSize(4)">4x4</button>
        </div>

        <button class="scramble" onclick="scrambleCube()">打乱魔方<span>SCRAMBLE</span></button>
        <button id="solve-btn" class="solve" style="display:none" onclick="startSolveAssist()">演示下一步<span>NEXT STEP</span></button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/**
 * 全局变量与配置
 */
let scene, camera, renderer, cubeGroup;
let cubies = [];
let cubeSize = 3;
let currentMode = 'Classic';
let isRotating = false;
let startTime = null;
let timerInterval = null;
let isScrambled = false;

const COLORS = {
    top: 0xffffff, bottom: 0xffff00, left: 0xffa500, 
    right: 0xff0000, front: 0x00ff00, back: 0x0046ad, inside: 0x1a1a1a
};

/**
 * 初始化 3D 场景
 */
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(6, 6, 11);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.9));
    const light = new THREE.PointLight(0xffffff, 0.3);
    light.position.set(10, 10, 10);
    scene.add(light);

    createCube();
    initInteraction();
    loadHistory(); // 初始化加载历史
    animate();

    window.addEventListener('resize', onResize);
}

/**
 * 生成魔方
 */
function createCube() {
    if (cubeGroup) scene.remove(cubeGroup);
    cubeGroup = new THREE.Group();
    cubies = [];

    const offset = (cubeSize - 1) / 2;
    for (let x = 0; x < cubeSize; x++) {
        for (let y = 0; y < cubeSize; y++) {
            for (let z = 0; z < cubeSize; z++) {
                if (x === 0 || x === cubeSize-1 || y === 0 || y === cubeSize-1 || z === 0 || z === cubeSize-1) {
                    const geometry = new THREE.BoxGeometry(0.96, 0.96, 0.96);
                    const mats = [
                        new THREE.MeshLambertMaterial({ color: x === cubeSize-1 ? COLORS.right : COLORS.inside }),
                        new THREE.MeshLambertMaterial({ color: x === 0 ? COLORS.left : COLORS.inside }),
                        new THREE.MeshLambertMaterial({ color: y === cubeSize-1 ? COLORS.top : COLORS.inside }),
                        new THREE.MeshLambertMaterial({ color: y === 0 ? COLORS.bottom : COLORS.inside }),
                        new THREE.MeshLambertMaterial({ color: z === cubeSize-1 ? COLORS.front : COLORS.inside }),
                        new THREE.MeshLambertMaterial({ color: z === 0 ? COLORS.back : COLORS.inside }),
                    ];
                    const cubie = new THREE.Mesh(geometry, mats);
                    cubie.position.set(x - offset, y - offset, z - offset);
                    cubeGroup.add(cubie);
                    cubies.push(cubie);
                }
            }
        }
    }
    scene.add(cubeGroup);
    resetTimer();
}

/**
 * 核心：层级旋转逻辑
 */
function rotateLayer(axis, layerIndex, angle = Math.PI / 2) {
    if (isRotating) return Promise.resolve();
    isRotating = true;

    return new Promise(resolve => {
        const pivot = new THREE.Group();
        scene.add(pivot);

        const offset = (cubeSize - 1) / 2;
        const targets = cubies.filter(c => {
            const pos = new THREE.Vector3();
            c.getWorldPosition(pos);
            return Math.abs(pos[axis] - (layerIndex - offset)) < 0.1;
        });

        targets.forEach(c => pivot.attach(c));

        new TWEEN.Tween(pivot.rotation)
            .to({ [axis]: pivot.rotation[axis] + angle }, 300)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                targets.forEach(c => cubeGroup.attach(c));
                scene.remove(pivot);
                isRotating = false;
                resolve();
            }).start();
    });
}

/**
 * 历史记录管理（保存最新的10个）
 */
function saveHistory(timeResult) {
    let logs = JSON.parse(localStorage.getItem('cube_pro_logs') || '[]');
    const newEntry = {
        mode: currentMode,
        modeCN: getModeName(currentMode),
        size: `${cubeSize}x${cubeSize}`,
        time: timeResult,
        timestamp: new Date().toLocaleString('zh-CN', { hour12: false })
    };

    logs.unshift(newEntry); // 添加到最前面
    if (logs.length > 10) logs = logs.slice(0, 10); // 只保留最新10个
    
    localStorage.setItem('cube_pro_logs', JSON.stringify(logs));
    loadHistory();
}

function loadHistory() {
    const logs = JSON.parse(localStorage.getItem('cube_pro_logs') || '[]');
    const listEl = document.getElementById('history-list');
    listEl.innerHTML = '';

    logs.forEach(log => {
        const li = document.createElement('li');
        li.className = 'history-item';
        li.innerHTML = `
            <div class="meta"><span>${log.timestamp}</span><span>${log.size}</span></div>
            <div class="data"><span>${log.modeCN}</span><span style="color:#f1c40f">${log.time}</span></div>
        `;
        listEl.appendChild(li);
    });
    document.getElementById('log-count').innerText = `${logs.length}/10`;
}

function getModeName(m) {
    const names = { 'Classic': '经典', 'Time Trial': '计时', 'Solve Assist': '辅助' };
    return names[m] || m;
}

/**
 * 模式与控制
 */
function changeMode(mode) {
    currentMode = mode;
    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${mode.replace(' ', '')}`).classList.add('active');
    
    const modeText = mode === 'Classic' ? '经典模式 Classic' : (mode === 'Time Trial' ? '计时挑战 Time Trial' : '辅助模式 Assist');
    document.getElementById('mode-text').innerText = modeText;
    document.getElementById('solve-btn').style.display = (mode === 'Solve Assist') ? 'flex' : 'none';
    resetTimer();
}

function changeSize(s) {
    cubeSize = s;
    document.getElementById('size-display').innerText = `尺寸 Size: ${s}x${s}`;
    createCube();
}

function scrambleCube() {
    isScrambled = true;
    let count = 0;
    const total = 12;
    const interval = setInterval(() => {
        const axes = ['x', 'y', 'z'];
        rotateLayer(axes[Math.floor(Math.random()*3)], Math.floor(Math.random()*cubeSize));
        if (++count >= total) {
            clearInterval(interval);
            if (currentMode === 'Time Trial') startTimer();
        }
    }, 350);
}

function startTimer() {
    startTime = Date.now();
    timerInterval = setInterval(() => {
        const diff = Date.now() - startTime;
        const m = Math.floor(diff / 60000).toString().padStart(2, '0');
        const s = Math.floor((diff % 60000) / 1000).toString().padStart(2, '0');
        const ms = Math.floor((diff % 1000) / 100);
        document.getElementById('timer-display').innerText = `${m}:${s}.${ms}`;
    }, 100);
}

function resetTimer() {
    clearInterval(timerInterval);
    document.getElementById('timer-display').innerText = "00:00.0";
}

function startSolveAssist() {
    // 演示：旋转中间层并记录
    rotateLayer('y', Math.floor(cubeSize/2), -Math.PI/2).then(() => {
        saveHistory("完成提示 Step Log");
    });
}

/**
 * 视角控制
 */
function initInteraction() {
    let isDragging = false;
    let lastX, lastY;

    const onStart = (x, y) => { isDragging = true; lastX = x; lastY = y; };
    const onMove = (x, y) => {
        if (!isDragging) return;
        cubeGroup.rotation.y += (x - lastX) * 0.01;
        cubeGroup.rotation.x += (y - lastY) * 0.01;
        lastX = x; lastY = y;
    };

    window.addEventListener('mousedown', e => onStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', () => isDragging = false);

    window.addEventListener('touchstart', e => onStart(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchmove', e => onMove(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchend', () => isDragging = false);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
