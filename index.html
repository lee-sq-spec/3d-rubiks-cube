<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rubik's Pro Max - Final Logic Fixed</title>
    <style>
        :root { --bg: #050505; --cyan: #00f2ff; --gold: #f1c40f; --panel: rgba(20, 20, 20, 0.98); }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'PingFang SC', sans-serif; color: white; touch-action: none; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 100; }
        .pointer { pointer-events: auto; }

        /* 左侧：状态与教学 */
        .left-panel { position: absolute; left: 20px; top: 20px; width: 240px; background: var(--panel); padding: 15px; border-radius: 12px; border: 1px solid #444; }
        .timer { font-family: monospace; font-size: 36px; color: var(--gold); text-align: center; margin: 10px 0; }
        .guide-text { font-size: 12px; color: #aaa; line-height: 1.6; border-top: 1px solid #333; padding-top: 10px; }

        /* 右侧：操作面板 (UDL RFB) - 解决遮挡 */
        .right-panel { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 8px; }
        .btn-move { 
            width: 60px; height: 60px; background: #2a2a2a; color: white; border: 1px solid #555; 
            border-radius: 12px; font-weight: bold; cursor: pointer; transition: 0.1s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .btn-move:active { background: var(--cyan); color: #000; transform: scale(0.9); }
        .btn-move span { font-size: 10px; font-weight: normal; opacity: 0.6; }

        /* 辅助模式专用工具 */
        #palette { display: none; position: absolute; right: 90px; top: 50%; transform: translateY(-50%); flex-direction: column; gap: 12px; }
        .ink { width: 35px; height: 35px; border-radius: 50%; border: 3px solid transparent; cursor: pointer; }
        .ink.active { border-color: white; box-shadow: 0 0 15px white; }

        /* 底部控制 */
        .bottom-area { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .mode-switch { display: flex; gap: 10px; background: #111; padding: 6px; border-radius: 10px; }
        .m-btn { background: none; color: #666; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; }
        .m-btn.active { background: var(--cyan); color: #000; font-weight: bold; }
        .btn-main { background: #e67e22; color: white; font-weight: bold; padding: 15px 50px; border-radius: 12px; border: none; font-size: 18px; cursor: pointer; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="left-panel pointer">
        <div id="mode-title" style="color:var(--cyan); font-weight:bold;">经典模式 CLASSIC</div>
        <div id="timer" class="timer">00:00.0</div>
        <div class="guide-text" id="guide-info">
            • <b>滑动背景</b>：旋转视角<br>
            • <b>右侧按钮</b>：旋转魔方层级<br>
            • <b>打乱</b>：开始计时挑战
        </div>
        <div id="solver-ui" style="display:none; margin-top:15px; border-top:1px solid #444; padding-top:15px;">
            <button onclick="startAutoSolve()" style="width:100%; padding:10px; background:#2ecc71; color:white; border:none; border-radius:6px; font-weight:bold; cursor:pointer;">智能生成复原路径</button>
            <div id="step-counter" style="text-align:center; font-size:12px; margin-top:8px; color:var(--gold);"></div>
        </div>
    </div>

    <div class="right-panel pointer" id="move-controls">
        <button class="btn-move" onclick="handleRotate('y', 2, 1)">U<span>顶层</span></button>
        <button class="btn-move" onclick="handleRotate('y', 0, -1)">D<span>底层</span></button>
        <button class="btn-move" onclick="handleRotate('x', 0, -1)">L<span>左层</span></button>
        <button class="btn-move" onclick="handleRotate('x', 2, 1)">R<span>右层</span></button>
        <button class="btn-move" onclick="handleRotate('z', 2, 1)">F<span>前层</span></button>
        <button class="btn-move" onclick="handleRotate('z', 0, -1)">B<span>后层</span></button>
    </div>

    <div id="palette" class="pointer">
        <div class="ink active" style="background:#fff" onclick="selectColor(0,this)"></div>
        <div class="ink" style="background:#ff0" onclick="selectColor(1,this)"></div>
        <div class="ink" style="background:#f90" onclick="selectColor(2,this)"></div>
        <div class="ink" style="background:#f00" onclick="selectColor(3,this)"></div>
        <div class="ink" style="background:#0f0" onclick="selectColor(4,this)"></div>
        <div class="ink" style="background:#00f" onclick="selectColor(5,this)"></div>
    </div>

    <div class="bottom-area pointer">
        <div class="mode-switch">
            <button id="btn-c" class="m-btn active" onclick="changeMode('Classic')">经典</button>
            <button id="btn-t" class="m-btn" onclick="changeMode('Time')">计时</button>
            <button id="btn-a" class="m-btn" onclick="changeMode('Assist')">辅助</button>
        </div>
        <button class="btn-main" onclick="onScramble()">打乱魔方 SCRAMBLE</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/**
 * 修复逻辑核心说明：
 * 1. 物理对齐：每一转完成后强行执行 Math.round，防止“碎纸片”。
 * 2. 复原路径：记录所有操作，辅助模式下进行“逆元运算”实现一键复原。
 * 3. 严格判定：检查每个方块的初始ID和当前四元数。
 */

let scene, camera, renderer, controls, cubeGroup, cubies = [];
let isAnimating = false, currentMode = 'Classic', activeInk = 0;
let moveStack = [], startTime, timerInterval, racing = false;
const COLORS = [0xffffff, 0xffff00, 0xffa500, 0xff0000, 0x00ff00, 0x0046ad];

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(10, 10, 15);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    const light = new THREE.DirectionalLight(0xffffff, 0.4);
    light.position.set(10, 20, 10);
    scene.add(light);

    buildCube();
    animate();

    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('pointerdown', onPointClick);
}

function buildCube() {
    if(cubeGroup) scene.remove(cubeGroup);
    cubeGroup = new THREE.Group();
    cubies = [];

    for(let x=0; x<3; x++) {
        for(let y=0; y<3; y++) {
            for(let z=0; z<3; z++) {
                if(x===1 && y===1 && z===1) continue;
                const geom = new THREE.BoxGeometry(0.97, 0.97, 0.97);
                const mats = [];
                for(let i=0; i<6; i++) {
                    let c = 0x1a1a1a;
                    if(i===0 && x===2) c = COLORS[3];
                    if(i===1 && x===0) c = COLORS[2];
                    if(i===2 && y===2) c = COLORS[0];
                    if(i===3 && y===0) c = COLORS[1];
                    if(i===4 && z===2) c = COLORS[4];
                    if(i===5 && z===0) c = COLORS[5];
                    mats.push(new THREE.MeshLambertMaterial({ color: c }));
                }
                const mesh = new THREE.Mesh(geom, mats);
                mesh.position.set(x-1, y-1, z-1);
                // 关键：锁定初始位置
                mesh.userData = { home: mesh.position.clone(), id: `${x}${y}${z}` };
                cubeGroup.add(mesh);
                cubies.push(mesh);
            }
        }
    }
    scene.add(cubeGroup);
}

// 物理转动引擎：彻底修复“碎纸片”
function handleRotate(axis, layer, dir, record = true) {
    if(isAnimating) return;
    isAnimating = true;

    if(record) moveStack.push({axis, layer, dir});

    const pivot = new THREE.Group();
    scene.add(pivot);

    const targets = cubies.filter(c => {
        const wp = new THREE.Vector3();
        c.getWorldPosition(wp);
        return Math.abs(wp[axis] - (layer - 1)) < 0.1;
    });

    targets.forEach(c => pivot.attach(c));

    const targetRot = (Math.PI / 2) * dir;
    new TWEEN.Tween(pivot.rotation).to({ [axis]: targetRot }, 300)
        .easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
            targets.forEach(c => {
                cubeGroup.attach(c);
                // 物理吸附：坐标和旋转取整，防止偏差累积导致破碎
                c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
                c.rotation.set(
                    Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2),
                    Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2),
                    Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2)
                );
            });
            scene.remove(pivot);
            isAnimating = false;
            if(racing) validateSolve();
        }).start();
}

function validateSolve() {
    const solved = cubies.every(c => {
        const posMatch = c.position.distanceTo(c.userData.home) < 0.1;
        const rotMatch = Math.abs(c.rotation.x % (Math.PI*2)) < 0.1 && 
                         Math.abs(c.rotation.y % (Math.PI*2)) < 0.1 && 
                         Math.abs(c.rotation.z % (Math.PI*2)) < 0.1;
        return posMatch && rotMatch;
    });

    if(solved && racing) {
        clearInterval(timerInterval);
        racing = false;
        alert("恭喜复原！耗时：" + document.getElementById('timer').innerText);
    }
}

function onScramble() {
    moveStack = [];
    let moves = 0;
    const itv = setInterval(() => {
        const axes = ['x','y','z'];
        handleRotate(axes[Math.floor(Math.random()*3)], Math.floor(Math.random()*3), 1);
        if(++moves >= 15) {
            clearInterval(itv);
            if(currentMode === 'Time') {
                startTime = Date.now();
                racing = true;
                timerInterval = setInterval(() => {
                    document.getElementById('timer').innerText = ((Date.now()-startTime)/1000).toFixed(1) + 's';
                }, 100);
            }
        }
    }, 400);
}

function changeMode(m) {
    currentMode = m; racing = false;
    clearInterval(timerInterval);
    document.getElementById('timer').innerText = "00:00.0";
    document.querySelectorAll('.m-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('btn-' + m[0].toLowerCase()).classList.add('active');
    
    document.getElementById('mode-title').innerText = m.toUpperCase() + (m==='Classic'?' / 经典模式':(m==='Time'?' / 计时模式':' / 辅助模式'));
    document.getElementById('palette').style.display = (m==='Assist'?'flex':'none');
    document.getElementById('solver-ui').style.display = (m==='Assist'?'block':'none');
    document.getElementById('move-controls').style.display = (m==='Assist'?'none':'flex');
    
    buildCube();
}

// 智能还原：逆元解法逻辑
function startAutoSolve() {
    if(moveStack.length === 0) return alert("已经是复原状态 / Already Solved");
    const steps = [...moveStack].reverse();
    moveStack = []; // 清空，防止递归
    
    let i = 0;
    const solveItv = setInterval(() => {
        const s = steps[i];
        handleRotate(s.axis, s.layer, -s.dir, false);
        document.getElementById('step-counter').innerText = `剩余步骤: ${steps.length - i - 1}`;
        if(++i >= steps.length) {
            clearInterval(solveItv);
            setTimeout(() => {
                document.getElementById('step-counter').innerText = "复原完成！";
                alert("已完成智能复原演示！");
            }, 500);
        }
    }, 500);
}

function selectColor(idx, el) {
    activeInk = idx;
    document.querySelectorAll('.ink').forEach(k => k.classList.remove('active'));
    el.classList.add('active');
}

function onPointClick(e) {
    if(currentMode !== 'Assist') return;
    const ray = new THREE.Raycaster();
    const m = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
    ray.setFromCamera(m, camera);
    const hits = ray.intersectObjects(cubies);
    if(hits.length > 0) {
        const faceIdx = Math.floor(hits[0].faceIndex / 2);
        hits[0].object.material[faceIdx].color.setHex(COLORS[activeInk]);
    }
}

function onResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
