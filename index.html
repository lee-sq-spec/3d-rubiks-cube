<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Rubik's Cube Ultimate | 3D 魔方旗舰版</title>
    <style>
        :root { --primary: #3498db; --accent: #2ecc71; --bg: #0d0d0d; --panel: rgba(25, 25, 25, 0.95); }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'PingFang SC', sans-serif; color: white; touch-action: none; }
        
        #game-ui { position: absolute; inset: 0; pointer-events: none; z-index: 100; display: flex; flex-direction: column; justify-content: space-between; padding: 15px; }
        .pointer { pointer-events: auto; }

        .header { display: flex; justify-content: space-between; align-items: flex-start; }
        .info-panel { background: var(--panel); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
        .timer { font-family: 'Courier New', monospace; font-size: 32px; color: #f1c40f; font-weight: bold; }
        
        .history-panel { width: 220px; background: var(--panel); border-radius: 12px; padding: 12px; font-size: 12px; border: 1px solid rgba(255,255,255,0.1); }
        .history-list { list-style: none; padding: 0; margin: 5px 0 0 0; max-height: 120px; overflow-y: auto; }
        .history-item { padding: 4px 0; border-bottom: 1px solid #333; display: flex; justify-content: space-between; }

        .controls { display: flex; flex-direction: column; align-items: center; gap: 15px; padding-bottom: 30px; }
        .btn-row { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        .btn-group { display: flex; background: var(--panel); padding: 5px; border-radius: 10px; gap: 5px; border: 1px solid rgba(255,255,255,0.1); }
        
        button { 
            background: #333; color: white; border: none; padding: 8px 15px; border-radius: 6px; 
            cursor: pointer; font-size: 13px; transition: 0.2s; display: flex; flex-direction: column; align-items: center;
        }
        button span { font-size: 10px; opacity: 0.6; }
        button.active { background: var(--primary); }
        button.scramble { background: #e67e22; font-weight: bold; padding: 12px 25px; font-size: 16px; }
        
        /* 辅助模式提示 */
        #assist-hint { 
            background: rgba(46, 204, 113, 0.2); border: 1px solid var(--accent); 
            padding: 8px; border-radius: 8px; margin-top: 10px; font-size: 12px; display: none;
        }

        @media (max-width: 600px) {
            .header { flex-direction: column; gap: 10px; }
            .history-panel { width: 100%; }
        }
    </style>
</head>
<body>

<div id="game-ui">
    <div class="header">
        <div class="info-panel pointer">
            <div id="mode-text" style="font-size:13px; color:#aaa">经典模式 Classic</div>
            <div id="timer-display" class="timer">00:00.0</div>
            <div id="assist-hint" class="pointer">点击魔方表面填色<br>Click faces to set color</div>
        </div>

        <div class="history-panel pointer">
            <div style="display:flex; justify-content:space-between; border-bottom:1px solid #444; padding-bottom:5px;">
                <span>历史记录 History (Latest 10)</span>
                <b id="log-count">0/10</b>
            </div>
            <ul id="history-list" class="history-list"></ul>
        </div>
    </div>

    <div class="controls pointer">
        <div class="btn-row">
            <div class="btn-group">
                <button onclick="changeMode('Classic')" id="btn-Classic" class="active">经典<span>Classic</span></button>
                <button onclick="changeMode('Time Trial')" id="btn-TimeTrial">计时<span>Time Trial</span></button>
                <button onclick="changeMode('Solve Assist')" id="btn-SolveAssist">辅助<span>Assist</span></button>
            </div>
            <div class="btn-group">
                <button onclick="changeSize(3)">3x3</button>
                <button onclick="changeSize(4)">4x4</button>
            </div>
        </div>
        
        <button class="scramble" onclick="handleMainAction()" id="main-action-btn">
            打乱魔方<br><span>SCRAMBLE</span>
        </button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/**
 * 核心逻辑修复说明：
 * 1. 使用拾取器 (Raycaster) 检测点击的具体方块面。
 * 2. 旋转时动态解耦，旋转后重新锁定坐标，防止“动不了”。
 */
let scene, camera, renderer, cubeGroup, raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
let cubies = [], cubeSize = 3, currentMode = 'Classic';
let isRotating = false, startTime = null, timerInterval = null, isPlaying = false;

const COLORS = [0xffffff, 0xffff00, 0xffa500, 0xff0000, 0x00ff00, 0x0046ad]; // 白, 黄, 橙, 红, 绿, 蓝
const COLOR_NAMES = ['White', 'Yellow', 'Orange', 'Red', 'Green', 'Blue'];

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(7, 7, 7);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    let light = new THREE.DirectionalLight(0xffffff, 0.4);
    light.position.set(10, 20, 10);
    scene.add(light);

    createCube();
    loadHistory();
    animate();

    window.addEventListener('mousedown', onPointerDown);
    window.addEventListener('touchstart', (e) => onPointerDown(e.touches[0]));
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function createCube() {
    if (cubeGroup) scene.remove(cubeGroup);
    cubeGroup = new THREE.Group();
    cubies = [];
    const offset = (cubeSize - 1) / 2;

    for (let x = 0; x < cubeSize; x++) {
        for (let y = 0; y < cubeSize; y++) {
            for (let z = 0; z < cubeSize; z++) {
                if (x === 0 || x === cubeSize - 1 || y === 0 || y === cubeSize - 1 || z === 0 || z === cubeSize - 1) {
                    const geom = new THREE.BoxGeometry(0.95, 0.95, 0.95);
                    const mats = [];
                    // 初始颜色赋予
                    for(let i=0; i<6; i++) {
                        let color = 0x111111;
                        if (i === 0 && x === cubeSize-1) color = COLORS[3]; // Right - Red
                        if (i === 1 && x === 0) color = COLORS[2];          // Left - Orange
                        if (i === 2 && y === cubeSize-1) color = COLORS[0]; // Top - White
                        if (i === 3 && y === 0) color = COLORS[1];          // Bottom - Yellow
                        if (i === 4 && z === cubeSize-1) color = COLORS[4]; // Front - Green
                        if (i === 5 && z === 0) color = COLORS[5];          // Back - Blue
                        mats.push(new THREE.MeshLambertMaterial({ color: color }));
                    }
                    const cubie = new THREE.Mesh(geom, mats);
                    cubie.position.set(x - offset, y - offset, z - offset);
                    // 记录原始相对坐标用于复原检测
                    cubie.userData = { home: cubie.position.clone() }; 
                    cubeGroup.add(cubie);
                    cubies.push(cubie);
                }
            }
        }
    }
    scene.add(cubeGroup);
    stopTimer();
}

// 核心：处理填色和视角
function onPointerDown(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(cubies);
    if (intersects.length > 0) {
        const hit = intersects[0];
        if (currentMode === 'Solve Assist') {
            // 辅助模式：点击变色
            const faceIndex = Math.floor(hit.faceIndex / 2);
            const mat = hit.object.material[faceIndex];
            let currColorIdx = COLORS.indexOf(mat.color.getHex());
            currColorIdx = (currColorIdx + 1) % COLORS.length;
            mat.color.setHex(COLORS[currColorIdx]);
        } else {
            // 经典/计时模式：点击并准备旋转视角（此处简化为点击方块即随机转动一层演示交互）
            // 在实际使用中，玩家可以拖拽屏幕空白处旋转视角
        }
    }
}

// 主按钮逻辑
function handleMainAction() {
    if (currentMode === 'Solve Assist') {
        alert("请根据您手上的魔方点击方块填色，完成后我们将开始引导步复原。");
        return;
    }
    scramble();
}

function scramble() {
    if (isRotating) return;
    isPlaying = true;
    let count = 0;
    const interval = setInterval(() => {
        const axes = ['x', 'y', 'z'];
        rotateLayer(axes[Math.floor(Math.random()*3)], Math.floor(Math.random()*cubeSize));
        if (++count > 10) {
            clearInterval(interval);
            if (currentMode === 'Time Trial') startTimer();
        }
    }, 300);
}

function rotateLayer(axis, layerIndex) {
    if (isRotating) return;
    isRotating = true;
    const pivot = new THREE.Group();
    scene.add(pivot);
    const offset = (cubeSize - 1) / 2;

    const targets = cubies.filter(c => {
        const pos = new THREE.Vector3();
        c.getWorldPosition(pos);
        return Math.abs(pos[axis] - (layerIndex - offset)) < 0.1;
    });

    targets.forEach(c => pivot.attach(c));
    new TWEEN.Tween(pivot.rotation).to({ [axis]: Math.PI / 2 }, 250).onComplete(() => {
        targets.forEach(c => {
            cubeGroup.attach(c);
            // 关键修复：旋转后舍入坐标，防止浮点数误差导致“卡死”
            c.position.x = Math.round(c.position.x * 10) / 10;
            c.position.y = Math.round(c.position.y * 10) / 10;
            c.position.z = Math.round(c.position.z * 10) / 10;
        });
        scene.remove(pivot);
        isRotating = false;
        if (isPlaying) checkSolved();
    }).start();
}

function checkSolved() {
    // 检查逻辑：是否所有方块都在原位且颜色朝向一致
    // 此处简化演示：如果计时器在跑且玩家点击了结束（或逻辑判断成功）
    // 在真实逻辑中，我们会对比 cubie.position 与 userData.home
}

// 计时器系统
function startTimer() {
    startTime = Date.now();
    timerInterval = setInterval(() => {
        const diff = Date.now() - startTime;
        const s = (diff / 1000).toFixed(1);
        document.getElementById('timer-display').innerText = s.padStart(4, '0') + 's';
    }, 100);
    document.getElementById('main-action-btn').innerHTML = "完成复原！<br><span>I'M DONE</span>";
    document.getElementById('main-action-btn').onclick = finishChallenge;
}

function finishChallenge() {
    stopTimer();
    const result = document.getElementById('timer-display').innerText;
    saveHistory(result);
    alert("挑战结束！用时: " + result);
    document.getElementById('main-action-btn').innerHTML = "重新打乱<br><span>SCRAMBLE</span>";
    document.getElementById('main-action-btn').onclick = handleMainAction;
}

function stopTimer() {
    clearInterval(timerInterval);
    isPlaying = false;
}

// 模式切换
function changeMode(mode) {
    currentMode = mode;
    document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${mode.replace(' ', '')}`).classList.add('active');
    document.getElementById('mode-text').innerText = (mode==='Classic'?'经典模式 Classic':(mode==='Time Trial'?'计时挑战 Time Trial':'辅助模式 Assist'));
    document.getElementById('assist-hint').style.display = (mode === 'Solve Assist') ? 'block' : 'none';
    if(mode === 'Solve Assist') {
        document.getElementById('main-action-btn').innerHTML = "开始引导复原<br><span>START SOLVE</span>";
    } else {
        document.getElementById('main-action-btn').innerHTML = "打乱魔方<br><span>SCRAMBLE</span>";
    }
}

function changeSize(s) { cubeSize = s; createCube(); }

// 历史记录持久化
function saveHistory(val) {
    let logs = JSON.parse(localStorage.getItem('cube_logs') || '[]');
    logs.unshift({ time: val, date: new Date().toLocaleTimeString(), size: cubeSize + 'x' + cubeSize });
    if (logs.length > 10) logs = logs.slice(0, 10);
    localStorage.setItem('cube_logs', JSON.stringify(logs));
    loadHistory();
}

function loadHistory() {
    const logs = JSON.parse(localStorage.getItem('cube_logs') || '[]');
    const list = document.getElementById('history-list');
    list.innerHTML = '';
    logs.forEach(l => {
        const li = document.createElement('li');
        li.className = 'history-item';
        li.innerHTML = `<span>${l.date} (${l.size})</span> <b>${l.time}</b>`;
        list.appendChild(li);
    });
    document.getElementById('log-count').innerText = logs.length + "/10";
}

// 视角旋转（拖拽空白处）
let isDragging = false, lastX, lastY;
window.addEventListener('mousedown', e => { if(e.target == document.body) { isDragging = true; lastX = e.clientX; lastY = e.clientY; }});
window.addEventListener('mousemove', e => {
    if(isDragging) {
        cubeGroup.rotation.y += (e.clientX - lastX) * 0.01;
        cubeGroup.rotation.x += (e.clientY - lastY) * 0.01;
        lastX = e.clientX; lastY = e.clientY;
    }
});
window.addEventListener('mouseup', () => isDragging = false);

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
