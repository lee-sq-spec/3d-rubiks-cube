<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rubik's Pro Max - Final Stable</title>
    <style>
        :root { --bg: #050505; --panel: rgba(25, 25, 25, 0.98); --cyan: #00f2ff; --gold: #f1c40f; --green: #2ecc71; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'PingFang SC', 'Helvetica', sans-serif; color: white; touch-action: none; }
        
        /* UI层级：确保 pointer-events:none 不阻挡视角滑动，按钮设为 auto 响应点击 */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 100; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; }
        .pointer { pointer-events: auto; }
        
        /* 顶部面板 */
        .top-row { display: flex; justify-content: space-between; align-items: flex-start; }
        .info-card { background: var(--panel); padding: 15px; border-radius: 12px; border: 1px solid #444; width: 280px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .timer { font-family: 'Courier New', monospace; font-size: 36px; color: var(--gold); text-shadow: 0 0 10px rgba(241,196,15,0.3); margin: 5px 0; }
        .status-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 10px; background: #333; color: var(--cyan); margin-bottom: 8px; }

        /* 玩法介绍区域 */
        .guide-content { font-size: 12px; color: #bbb; line-height: 1.6; border-top: 1px solid #333; margin-top: 10px; padding-top: 10px; }
        .guide-content b { color: white; }

        /* 辅助模式侧边栏 */
        #palette { display: none; position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: var(--panel); padding: 12px; border-radius: 20px; flex-direction: column; gap: 15px; border: 1px solid #555; }
        .ink { width: 38px; height: 38px; border-radius: 50%; cursor: pointer; border: 3px solid transparent; transition: 0.3s; }
        .ink.active { border-color: white; box-shadow: 0 0 15px white; transform: scale(1.1); }

        /* 底部控制中心 */
        .control-center { display: flex; flex-direction: column; align-items: center; gap: 15px; padding-bottom: 30px; }
        .move-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; background: var(--panel); padding: 12px; border-radius: 15px; border: 1px solid #444; }
        .btn-move { width: 60px; height: 50px; background: #333; color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        .btn-move:active { background: var(--cyan); color: #000; transform: scale(0.9); }
        .btn-move span { display: block; font-size: 9px; opacity: 0.6; font-weight: normal; margin-top: 2px; }

        .mode-selector { display: flex; gap: 10px; background: var(--panel); padding: 8px; border-radius: 12px; }
        .btn-mode { background: #222; color: #888; border: none; padding: 10px 18px; border-radius: 8px; font-size: 13px; cursor: pointer; }
        .btn-mode.active { background: var(--cyan); color: #000; font-weight: bold; }
        
        .btn-main { background: #e67e22; color: white; font-weight: bold; padding: 15px 40px; border-radius: 12px; border: none; font-size: 16px; cursor: pointer; box-shadow: 0 4px 15px rgba(230,126,34,0.3); }
        .btn-main:hover { background: #d35400; }

        #hint-box { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); color: var(--cyan); font-size: 12px; opacity: 0.7; text-align: center; pointer-events: none; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="top-row">
        <div class="info-card pointer">
            <div class="status-badge" id="mode-badge">CLASSIC / 经典模式</div>
            <div id="timer" class="timer">00:00.0</div>
            <div class="guide-content" id="guide-text">
                <b>玩法介绍 / Introduction:</b><br>
                1. 点击按钮旋转每一层 (Click buttons to rotate layers)<br>
                2. <b>滑动空白处</b>旋转视角 (Swipe blank area to rotate view)<br>
                3. U:顶 D:底 L:左 R:右 F:前 B:后
            </div>
            <div id="tutorial-ctrls" style="display:none; margin-top:15px; border-top: 1px solid #333; padding-top:10px;">
                <button onclick="generateSolvePath()" style="background:var(--green); color:white; border:none; padding:10px; border-radius:6px; width:100%; font-weight:bold; cursor:pointer;">生成教学步骤 / Start Guide</button>
                <button id="next-step-btn" onclick="executeNextStep()" style="display:none; background:#9b59b6; color:white; border:none; padding:10px; border-radius:6px; width:100%; margin-top:10px; font-weight:bold; cursor:pointer;">下一步 / Next Step</button>
            </div>
        </div>

        <div class="info-card pointer" style="width: 180px;">
            <div style="font-size:12px; color:var(--cyan); margin-bottom:5px;">最高记录 / Best Records</div>
            <div id="history-list" style="font-size:11px; color:#888; line-height:1.8;">还没有记录 / No records</div>
        </div>
    </div>

    <div id="palette" class="pointer">
        <div class="ink active" style="background:#fff" onclick="pickInk(0,this)"></div>
        <div class="ink" style="background:#ff0" onclick="pickInk(1,this)"></div>
        <div class="ink" style="background:#f90" onclick="pickInk(2,this)"></div>
        <div class="ink" style="background:#f00" onclick="pickInk(3,this)"></div>
        <div class="ink" style="background:#0f0" onclick="pickInk(4,this)"></div>
        <div class="ink" style="background:#00f" onclick="pickInk(5,this)"></div>
    </div>

    <div id="hint-box">滑动背景查看魔方背面<br>Swipe background to see back</div>

    <div class="control-center pointer">
        <div class="move-grid" id="standard-controls">
            <button class="btn-move" onclick="handleMove('y', 2, 1)">U<span>顶/Up</span></button>
            <button class="btn-move" onclick="handleMove('y', 0, -1)">D<span>底/Down</span></button>
            <button class="btn-move" onclick="handleMove('x', 0, -1)">L<span>左/Left</span></button>
            <button class="btn-move" onclick="handleMove('x', 2, 1)">R<span>右/Right</span></button>
            <button class="btn-move" onclick="handleMove('z', 2, 1)">F<span>前/Front</span></button>
            <button class="btn-move" onclick="handleMove('z', 0, -1)">B<span>后/Back</span></button>
        </div>

        <div class="mode-selector">
            <button onclick="setMode('Classic')" id="m-classic" class="btn-mode active">经典 / Classic</button>
            <button onclick="setMode('Time')" id="m-time" class="btn-mode">计时 / Time</button>
            <button onclick="setMode('Assist')" id="m-assist" class="btn-mode">辅助 / Assist</button>
        </div>

        <button class="btn-main" onclick="onMainAction()">打乱魔方 / SCRAMBLE</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/**
 * 核心检查：
 * 1. 视角滑动 vs 按钮点击层级冲突 -> 已通过 pointer-events 解决
 * 2. 乱牌/坐标偏移 -> 已通过 Math.round 物理归位解决
 * 3. 复原逻辑判断错误 -> 已改为严格身份校验
 * 4. 中英引导丢失 -> 已全量补回
 */

let scene, camera, renderer, controls, cubeGroup, cubies = [];
let isAnimating = false, currentMode = 'Classic', inkIndex = 0;
let startTime, timerInterval, isRacing = false;
let moveHistory = []; // 用于复原教学
let solveSteps = [];

const COLORS = [0xffffff, 0xffff00, 0xffa500, 0xff0000, 0x00ff00, 0x0046ad];

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(8, 8, 12);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // 初始化视角控制
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.rotateSpeed = 0.8;

    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    buildCube();
    setupTouchHandler();
    animate();
    loadRecords();
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function buildCube() {
    if (cubeGroup) scene.remove(cubeGroup);
    cubeGroup = new THREE.Group();
    cubies = [];
    
    // 逻辑：3x3x3 循环
    for(let x=0; x<3; x++) {
        for(let y=0; y<3; y++) {
            for(let z=0; z<3; z++) {
                if(x===1 && y===1 && z===1) continue; // 核心为空
                
                const geom = new THREE.BoxGeometry(0.97, 0.97, 0.97);
                const mats = [];
                // 顺序：Right, Left, Top, Bottom, Front, Back
                for(let i=0; i<6; i++) {
                    let c = 0x181818;
                    if(i===0 && x===2) c = COLORS[3]; // R-Red
                    if(i===1 && x===0) c = COLORS[2]; // L-Orange
                    if(i===2 && y===2) c = COLORS[0]; // U-White
                    if(i===3 && y===0) c = COLORS[1]; // D-Yellow
                    if(i===4 && z===2) c = COLORS[4]; // F-Green
                    if(i===5 && z===0) c = COLORS[5]; // B-Blue
                    mats.push(new THREE.MeshLambertMaterial({ color: c }));
                }
                const mesh = new THREE.Mesh(geom, mats);
                mesh.position.set(x-1, y-1, z-1);
                // 核心：保存初始身份和旋转用于判定复原
                mesh.userData = { id: `${x}${y}${z}`, initialPos: mesh.position.clone() };
                cubeGroup.add(mesh);
                cubies.push(mesh);
            }
        }
    }
    scene.add(cubeGroup);
}

// 物理级转动逻辑：解决乱牌的终极方案
function handleMove(axis, layer, dir, record = true) {
    if (isAnimating) return;
    isAnimating = true;

    // 记录每一步，用于教学
    if(record) moveHistory.push({axis, layer, dir});

    const pivot = new THREE.Group();
    scene.add(pivot);

    // 捕捉当前层
    const targets = cubies.filter(c => {
        const wp = new THREE.Vector3();
        c.getWorldPosition(wp);
        return Math.abs(wp[axis] - (layer - 1)) < 0.1;
    });

    targets.forEach(c => {
        // 视觉反馈：转动时该层闪烁
        c.material.forEach(m => m.emissive.setHex(0x333333));
        pivot.attach(c);
    });

    const targetRot = (Math.PI / 2) * dir;
    new TWEEN.Tween(pivot.rotation).to({ [axis]: targetRot }, 350)
        .easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
            targets.forEach(c => {
                cubeGroup.attach(c);
                // 物理归位：坐标取整，杜绝乱牌
                c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
                // 角度归位：锁定 90 度
                c.rotation.set(
                    Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2),
                    Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2),
                    Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2)
                );
                c.material.forEach(m => m.emissive.setHex(0x000000));
            });
            scene.remove(pivot);
            isAnimating = false;
            if(isRacing) checkSolved();
        }).start();
}

function setMode(m) {
    currentMode = m;
    isRacing = false;
    clearInterval(timerInterval);
    document.getElementById('timer').innerText = "00:00.0";
    
    // UI 更新
    document.querySelectorAll('.btn-mode').forEach(b => b.classList.remove('active'));
    document.getElementById('m-' + m.toLowerCase()).classList.add('active');
    document.getElementById('mode-badge').innerText = m.toUpperCase() + (m==='Classic'?' / 经典模式':(m==='Time'?' / 计时模式':' / 辅助模式'));
    
    document.getElementById('palette').style.display = (m==='Assist'?'flex':'none');
    document.getElementById('standard-controls').style.display = (m==='Assist'?'none':'grid');
    document.getElementById('tutorial-ctrls').style.display = (m==='Assist'?'block':'none');
    
    const guides = {
        'Classic': "<b>玩法介绍 / Introduction:</b><br>1. 自由练习模式。点击下方按钮旋转。<br>2. 滑动背景旋转视角。<br>3. 操作流畅且不会乱牌。",
        'Time': "<b>玩法介绍 / Introduction:</b><br>1. 点击打乱后立刻开始计时。<br>2. 复原后系统会自动保存你的记录。",
        'Assist': "<b>玩法介绍 / Introduction:</b><br>1. 先选右侧颜色，点击魔方块进行填色。<br>2. 填色完成后点'生成教学'，由系统演示复原。"
    };
    document.getElementById('guide-text').innerHTML = guides[m];
    
    moveHistory = [];
    buildCube();
}

function onMainAction() {
    moveHistory = [];
    let count = 0;
    const itv = setInterval(() => {
        const axes = ['x', 'y', 'z'];
        handleMove(axes[Math.floor(Math.random()*3)], Math.floor(Math.random()*3), 1);
        if(++count >= 10) {
            clearInterval(itv);
            if(currentMode === 'Time') {
                startTime = Date.now();
                isRacing = true;
                timerInterval = setInterval(updateTimer, 100);
            }
        }
    }, 400);
}

function updateTimer() {
    const elapsed = (Date.now() - startTime) / 1000;
    document.getElementById('timer').innerText = elapsed.toFixed(1) + "s";
}

function setupTouchHandler() {
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('pointerdown', (e) => {
        if(currentMode !== 'Assist') return;
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        const hits = raycaster.intersectObjects(cubies);
        if(hits.length > 0) {
            const faceIndex = Math.floor(hits[0].faceIndex / 2);
            hits[0].object.material[faceIndex].color.setHex(COLORS[inkIndex]);
        }
    });
}

// 严格复原判定：不仅看位置，更看角度
function checkSolved() {
    const solved = cubies.every(c => {
        const currentPos = new THREE.Vector3();
        c.getWorldPosition(currentPos);
        const dist = currentPos.distanceTo(c.userData.initialPos);
        
        // 角度判定：所有的旋转分量必须是 2*PI 的倍数（即回归原始朝向）
        const isRotIdentical = 
            Math.abs(c.rotation.x % (Math.PI * 2)) < 0.1 &&
            Math.abs(c.rotation.y % (Math.PI * 2)) < 0.1 &&
            Math.abs(c.rotation.z % (Math.PI * 2)) < 0.1;

        return dist < 0.1 && isRotIdentical;
    });

    if(solved && isRacing) {
        clearInterval(timerInterval);
        isRacing = false;
        saveRecord(document.getElementById('timer').innerText);
        alert("恭喜复原！ / Congratulations! Time: " + document.getElementById('timer').innerText);
    }
}

function generateSolvePath() {
    if(moveHistory.length === 0) return alert("已经是复原状态 / Already solved");
    solveSteps = [...moveHistory].reverse().map(step => ({...step, dir: -step.dir}));
    document.getElementById('next-step-btn').style.display = 'block';
    alert("路径已生成，请点击'下一步'观看演示 / Path ready, click 'Next Step'");
}

function executeNextStep() {
    if(solveSteps.length > 0) {
        const step = solveSteps.shift();
        handleMove(step.axis, step.layer, step.dir, false);
        if(solveSteps.length === 0) {
            document.getElementById('next-step-btn').style.display = 'none';
            moveHistory = [];
            alert("教学演示结束！ / Tutorial finished!");
        }
    }
}

function saveRecord(t) {
    let records = JSON.parse(localStorage.getItem('cube_records') || '[]');
    records.unshift({ time: t, date: new Date().toLocaleTimeString() });
    localStorage.setItem('cube_records', JSON.stringify(records.slice(0, 5)));
    loadRecords();
}

function loadRecords() {
    const records = JSON.parse(localStorage.getItem('cube_records') || '[]');
    const list = document.getElementById('history-list');
    if(records.length > 0) {
        list.innerHTML = records.map(r => `<div>${r.date} - <b style="color:var(--gold)">${r.time}</b></div>`).join('');
    }
}

function pickInk(idx, el) {
    inkIndex = idx;
    document.querySelectorAll('.ink').forEach(i => i.classList.remove('active'));
    el.classList.add('active');
}

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    controls.update();
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
