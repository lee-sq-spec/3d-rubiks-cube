<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rubik's Stable 360</title>
    <style>
        :root { --bg: #0a0a0a; --panel: rgba(20, 20, 20, 0.9); --cyan: #00f2ff; }
        body { margin: 0; overflow: hidden; background: var(--bg); color: white; touch-action: none; font-family: sans-serif; }
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 15px; }
        .pointer { pointer-events: auto; }
        .card { background: var(--panel); padding: 10px; border-radius: 12px; border: 1px solid #333; width: 220px; }
        .move-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; background: var(--panel); padding: 10px; border-radius: 12px; }
        button { background: #333; color: white; border: none; padding: 8px; border-radius: 4px; cursor: pointer; font-weight: bold; }
        button:active { background: var(--cyan); color: #000; }
        .mode-btn.active { background: var(--cyan); color: #000; }
        #hint { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--cyan); opacity: 0.5; pointer-events: none; font-size: 12px; }
    </style>
</head>
<body>

<div id="hint">滑动背景旋转视角 / Swipe background to rotate</div>

<div id="ui">
    <div class="card pointer">
        <div id="timer" style="font-size: 24px; color: #f1c40f; font-family: monospace;">00:00.0</div>
        <div style="font-size: 11px; margin-top:5px;">模式/Mode: <span id="mode-name">经典 Classic</span></div>
    </div>

    <div style="display:flex; flex-direction:column; align-items:center; gap:10px;">
        <div class="move-grid pointer">
            <button onclick="handleMove('y', 2, 1)">U</button>
            <button onclick="handleMove('y', 0, -1)">D</button>
            <button onclick="handleMove('x', 0, -1)">L</button>
            <button onclick="handleMove('x', 2, 1)">R</button>
            <button onclick="handleMove('z', 2, 1)">F</button>
            <button onclick="handleMove('z', 0, -1)">B</button>
        </div>
        <div class="pointer" style="display:flex; gap:5px;">
            <button onclick="setMode('Classic')" id="m-c" class="mode-btn active">经典</button>
            <button onclick="setMode('Time')" id="m-t" class="mode-btn">计时</button>
            <button onclick="scramble()" style="background:#e67e22;">打乱 SCRAMBLE</button>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
let scene, camera, renderer, controls, cubeGroup, cubies = [];
let isAnimating = false;

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(6, 6, 9);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 视角控制器
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // 增加滑动的手感阻尼
    controls.dampingFactor = 0.05;

    const light = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(light);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(10, 10, 10);
    scene.add(dirLight);

    createCube();
    animate();
}

function createCube() {
    if (cubeGroup) scene.remove(cubeGroup);
    cubeGroup = new THREE.Group();
    cubies = [];
    const colors = [0xffffff, 0xffff00, 0xffa500, 0xff0000, 0x00ff00, 0x0046ad];
    for (let x = 0; x < 3; x++) {
        for (let y = 0; y < 3; y++) {
            for (let z = 0; z < 3; z++) {
                if (x === 1 && y === 1 && z === 1) continue;
                const geom = new THREE.BoxGeometry(0.96, 0.96, 0.96);
                const mats = colors.map(c => new THREE.MeshLambertMaterial({ color: c }));
                const mesh = new THREE.Mesh(geom, mats);
                mesh.position.set(x - 1, y - 1, z - 1);
                cubeGroup.add(mesh);
                cubies.push(mesh);
            }
        }
    }
    scene.add(cubeGroup);
}

// 解决乱牌的关键函数
function handleMove(axis, layer, dir) {
    if (isAnimating) return;
    isAnimating = true;

    const pivot = new THREE.Group();
    scene.add(pivot);

    // 选取当前层的块
    const targets = cubies.filter(c => {
        const wp = new THREE.Vector3();
        c.getWorldPosition(wp);
        return Math.abs(wp[axis] - (layer - 1)) < 0.1;
    });

    targets.forEach(c => pivot.attach(c));

    const targetRotation = (Math.PI / 2) * dir;
    new TWEEN.Tween(pivot.rotation)
        .to({ [axis]: targetRotation }, 300)
        .easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
            // 核心修复步骤：
            targets.forEach(c => {
                cubeGroup.attach(c);
                // 1. 强制坐标四舍五入对齐
                c.position.x = Math.round(c.position.x);
                c.position.y = Math.round(c.position.y);
                c.position.z = Math.round(c.position.z);
                // 2. 强制旋转弧度归位 (90度的倍数)
                c.rotation.x = Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2);
                c.rotation.y = Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2);
                c.rotation.z = Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2);
            });
            scene.remove(pivot);
            isAnimating = false;
        }).start();
}

function scramble() {
    let count = 0;
    const timer = setInterval(() => {
        const axes = ['x', 'y', 'z'];
        handleMove(axes[Math.floor(Math.random()*3)], Math.floor(Math.random()*3), 1);
        if (++count >= 10) clearInterval(timer);
    }, 400);
}

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    controls.update(); // 更新视角滑动
    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>
